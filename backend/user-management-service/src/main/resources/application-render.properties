# =========================================
# RENDER PROFILE - USER MANAGEMENT SERVICE
# =========================================

# SERVER - Render requires explicit port binding to 0.0.0.0:PORT for health checks
server.port=${PORT:10000}
server.address=0.0.0.0
server.servlet.context-path=/api/auth
# Ensure Tomcat binds to all network interfaces
server.tomcat.address=0.0.0.0

# DISABLE SSL FOR RENDER DEPLOYMENT (Render handles SSL at platform level)
server.ssl.enabled=false

# RENDER DATABASE CONFIGURATION - Uses Supabase PostgreSQL with prepared statement fixes
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://aws-0-us-east-1.pooler.supabase.com:5432/postgres?sslmode=require&cachePrepStmts=false&useServerPrepStmts=false&prepareThreshold=0}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=${DB_USERNAME:postgres}
spring.datasource.password=${DB_PASSWORD:CoolLife@AriaDB}

# Connection Pool Settings optimized for Render free tier with prepared statement fixes
spring.datasource.hikari.maximum-pool-size=8
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=900000
spring.datasource.hikari.leak-detection-threshold=60000
# Fix prepared statement conflicts with Supabase pooler
spring.datasource.hikari.data-source-properties.cachePrepStmts=false
spring.datasource.hikari.data-source-properties.useServerPrepStmts=false
spring.datasource.hikari.data-source-properties.rewriteBatchedStatements=true

# JPA Configuration - TEMPORARILY DISABLED for port binding test
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration
# spring.jpa.hibernate.ddl-auto=update
# spring.jpa.show-sql=false
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
# spring.jpa.properties.hibernate.format_sql=false
# spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
# spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# FLYWAY MIGRATIONS - TEMPORARILY DISABLED for initial port binding test
# Re-enable after confirming port binding works
spring.flyway.enabled=false
# spring.flyway.locations=classpath:db/migration/postgresql
# spring.flyway.baseline-on-migrate=true
# spring.flyway.validate-on-migrate=false
# spring.flyway.clean-disabled=true
# spring.flyway.out-of-order=true
# Supabase pooler compatibility settings
# spring.flyway.mixed=true
# spring.flyway.connect-retries=3
# spring.flyway.connect-retries-interval=10

# UPSTASH REDIS CONFIGURATION - FIXED FOR RENDER
# Use host/port format instead of URL to avoid localhost fallback
spring.redis.host=${UPSTASH_REDIS_HOST:renewing-falcon-41265.upstash.io}
spring.redis.port=${UPSTASH_REDIS_PORT:6379}
spring.redis.password=${UPSTASH_REDIS_PASSWORD:AaExAAIncDE3NTczYWIxNDNjYjA0NzI2YWQ2NmY0ZTZjZTg5Y2IyMXAxNDEyNjU}
spring.redis.ssl.enabled=true
spring.redis.timeout=3000ms
spring.redis.database=0
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=4
spring.redis.lettuce.pool.min-idle=2
spring.redis.connect-timeout=5000ms

# JWT CONFIG
app.jwt.secret=${JWT_SECRET:kV7pL9zR3mX1tU5qW8bC2yJ6fH4nE0sDmA3gK9xZ2vF8uQ4tY7rP1wE6iO5sL0hN}
app.jwt.expiry-ms=${JWT_EXPIRY_MS:3600000}
app.jwt.refresh-expiry-ms=${JWT_REFRESH_EXPIRY_MS:604800000}
app.jwt.issuer=${JWT_ISSUER:ARIA-Render}

# MAIL CONFIGURATION
spring.mail.host=${SMTP_HOST:smtp.gmail.com}
spring.mail.port=${SMTP_PORT:587}
spring.mail.username=${SMTP_USERNAME:workwithrvprajwal@gmail.com}
spring.mail.password=${SMTP_PASSWORD:vclhowpwtmopdqdz}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.default-encoding=UTF-8

# MULTIPART FILE UPLOAD - Render optimized
spring.servlet.multipart.max-file-size=5MB
spring.servlet.multipart.max-request-size=10MB
spring.servlet.multipart.enabled=true

# LOGGING - Optimized for Render with debug info for port binding
logging.level.org.springframework=INFO
logging.level.com.company=INFO
logging.level.root=WARN
logging.level.org.flywaydb=INFO
# Enable debug logging for Tomcat and server startup
logging.level.org.apache.catalina.core=INFO
logging.level.org.springframework.boot.web.embedded.tomcat=INFO
logging.level.org.springframework.boot.web.servlet.context=INFO
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# SECURITY HEADERS - Render production
server.servlet.session.cookie.secure=true
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.same-site=strict

# ACTUATOR - Render compatible
management.endpoints.web.exposure.include=health,metrics,prometheus
management.endpoint.health.show-details=when-authorized
management.metrics.export.prometheus.enabled=true
management.security.enabled=true
# Make Redis health check non-blocking to prevent health check failures
management.health.redis.enabled=false
management.health.defaults.enabled=true

# CORS - Render domains
app.cors.allowed-origins=${CORS_ORIGINS:https://aria-frontend.onrender.com,https://aria-user-management.onrender.com}
app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
app.cors.allowed-headers=Authorization,Content-Type,X-Requested-With,Accept,Origin
app.cors.allow-credentials=true

# Render-specific optimizations
server.forward-headers-strategy=framework
server.tomcat.remote-ip-header=x-forwarded-for
server.tomcat.protocol-header=x-forwarded-proto

# Environment detection
environment=${RENDER_SERVICE_NAME:render}

# Health check endpoint for Render
management.endpoint.health.probes.enabled=true
management.health.readinessstate.enabled=true
management.health.livenessstate.enabled=true
